WRITING A CUSTOM KEYMAP

To write your own keymap is fairly easy. Here's how to use the example
Nano.hs keymap:
    $ cp examples/Config.hs ~/.yi/
    $ cp keymaps/Nano.hs ~/.yi

    -- Now edit ~/.yi/Config.hs to use ~/.yi/Nano.hs
    you need to replace:
                "import qualified Keymap" 
           with "import qualified Nano"

           and  "keymap = Keymap.keymap"
           with "keymap = Nano.keymap"

    and you're done. Restarting will use the new keymap.
    $ ./yi-inplace

RUNTIME

Preferences are stored in ~/.yi/Config.hs. Look in examples/ for example
Config.hs. If this directory doesn't exist, yi uses Yi/Keymap.hs for for
the defaults key mapping defaults, this is also what is used in
yi-static.

To get at yi internals from your config script, either import Yi.Yi,
which brings most of the commonly used modules into scope, or explicitly
import something from Yi/*. You can read the haddock-generated docs from
some (preliminary) api details (make html).

How do things load in the dynamic loader.
        
           Boot.hs
          /      \
      Config.hs Yi.o
                  |
                HSyi.o (-package yi)

once it is all loaded, Boot.main jumps to Yi.dynamic\_main

BUILD SYSTEM

Extra args can be passed at runtime as: make HC\_OPTS=-ddump-minimal-imports

DEVELOPMENT

Profiling:
You can build yi-static for profiling. Just set:
	make way=p
and then invoke
	./yi-static +RTS -p
and once you quit you'll get a yi-static.prof file with profiling
statistics.

Coding guidelines:

Please make sure you code compiles with -Wall, with no warnings. Use
Haddock markup to document any functions that are exported -- user's may
want to use this code at some point. We use cpp to pass platform
specific options into files. Please provide explicit import lists where
reasonable, and keep imports in some sorted order.  Please don't
introduce posix dependencies unless you absolutely have to.

You can actually run this stuff in ghci! To just run yi-core (the gui
etc, without worrying about booting the thing):

\begin{verbatim}
        ghci -package-conf yi.conf -package yi
        manzano$ ghci -package-conf yi.conf -package yi
           ___         ___ _
          / _ \ /\  /\/ __(_)
         / /_\// /_/ / /  | |      GHC Interactive, version 6.3, for Haskell 98.
        / /_\\/ __  / /___| |      http://www.haskell.org/ghc/
        \____/\/ /_/\____/|_|      Type :? for help.

        Loading package base ... linking ... done.
        Loading package haskell98 ... linking ... done.
        Loading package mtl ... linking ... done.
        Loading package lang ... linking ... done.
        Loading package unix ... linking ... done.
        Loading package posix ... linking ... done.
        Loading package yi ... linking ... done.
        Prelude> :l Main
        Prelude Main> main
\end{verbatim}

To run the whole thing is a bit harder, and requires faking the package
lib flags in yi.conf (leave off the last 2 args if you're on linux). And
if we haven't installed it yet (you want to run in-tree), then you have
to set the command line args. Also, to do this trick you need ghc-6.2.2
or greater, which contain appropriate rts patches for running dynamic
loaders dynamically.

\begin{verbatim}
        manzano$ ghci -package plugins -liconv -L/usr/local/lib
           ___         ___ _
          / _ \ /\  /\/ __(_)
         / /_\// /_/ / /  | |      GHC Interactive, version 6.3, for Haskell 98.
        / /_\\/ __  / /___| |      http://www.haskell.org/ghc/
        \____/\/ /_/\____/|_|      Type :? for help.

        Loading package base ... linking ... done.
        Loading package altdata ... linking ... done.
        Loading package haskell98 ... linking ... done.
        Loading package hi ... linking ... done.
        Loading package unix ... linking ... done.
        Loading package haskell-src ... linking ... done.
        Loading package mtl ... linking ... done.
        Loading package lang ... linking ... done.
        Loading package posix ... linking ... done.
        Loading package plugins ... linking ... done.
        Loading object (dynamic) iconv ... done
        final link ... done
	Prelude> :set -cpp -fglasgow-exts
	Prelude> :set -DLIBDIR="/usr/local/lib/yi"
	Prelude> :set args -B/home/dons/src/projects/yi
	Prelude> :l Boot.hs
	*Boot>
        Prelude Boot> main
        Starting up dynamic Haskell ... jumping over the edge ... done.
\end{verbatim}

For example, to modify \code{\$(TOP)/Yi.hs} in ghci, you would:

\begin{verbatim}
        manzano$ ghci -package-conf yi.conf -package yi -cpp -fglasgow-exts
        Prelude> :l Yi.hs
        *Yi> :t dynamic_main
        dynamic_main :: Maybe ConfigData -> IO ()
        *Yi> :reload
        Compiling Yi           ( Yi.hs, interpreted )
\end{verbatim}

\begin{thebibliography}[50]
\bibitem Emacs, The extensible, customizable ... Stallman.
\end{thebibliography}
