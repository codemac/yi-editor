This is a first post in a series where I will write a guide to start hacking on Yi.
In this post I'll give a very high-level view of Yi's structure.

Yi code can be categorized into four parts:

* Actions: these are operation that have some effect on the editor
  state.  This can be opening or saving a file, or moving the cursor
  in the current buffer.

* Keymaps: this code governs how the user input maps to
  actions. Yi comes with keymaps for emacs and vi emulation.

* UI: the code for rendering the editor state, and getting the
  stream of input events from the user. Yi comes with console, gtk and
  cocoa UI.
  
* Glue: ties the knot between Keymaps and UI.


The structure described above is very flexible: there is very low
coupling between layers. Indeed, one can easily swap out a component
for another in the same category. For example, the user can choose
between various UI components and key-bindings. The various DSLs have
composability properties, and this makes convenient to extend (and
configure) the editor.

The "actions" part makes up the most of the editor code. This part is
structured around a stack of three monadic, embedded DSLs.

  * BufferM: A DSL for all buffer-local operations, like insertion
  and deletion of text, and annotation of buffer contents. It can be
  understood as a monad that encapsulates the state of one
  buffer.
  
  * EditorM: A DSL for editor-level operations, e.g., opening and
  closing windows and buffers. Operations involving more than one
  buffer are handled at this level too.

  * YiM: A DSL for IO-level operations. There, one can operate on
  files, processes, etc.  This is the only level where IO can be
  done.

In the next post we'll use this knowledge and learn how to configure
Yi.


