% Prototypes: Encoding Object Oriented inheritance in Haskell

In this post I will sketch an encoding of OO-style inheritance in Haskell, and
how this can be used to our advantage to write code that can be customized.

This can serve as an introduction to the concepts defined in Yi's module
Data.Prototype.

## Inheritance: a reminder

Inheritance can create structures which are difficult to understand. Since a
given method call can call dispatch to a number of methods at runtime, tracking
what's going on might be tricky.

Sometimes however, this is exactly the construct we need.

Imagine you have the following piece of code

~~~~
a :: A
a = fa b c

b :: B
b = fb a c

c :: C
c = fc a b
~~~~

That `a`, `b` and `c` are defined in terms of each other.

You realise that you'd like users to be able to customize `a` by change the value of `c`.
Unfortunately, `a`'s value is *closed*, so this is not possible.

This situation seems to cry for inheritance... In an object oriented language,
the solution is obvious: make `a`, `b` and `c` methods of a class. The user can
then inherit it and override the definition of `c`. 

In Yi, we have user-interface themes that have this structure: specific styles 
are defined in terms of general ones, and we'd like the user to make only a few
changes in pre-defined prototypes, not redefine everything from the ground up.

So, what can we do, since we are stuck with a purely functional language,
Haskell?


## Encoding prototypes

All is not lost! [Pierce (TAPL, paragraph 18.10)][TAPL] has taught us that 
inheritance can be encoded as _open recursion_. The trick is to make the
reference to the `self` object explicit.

~~~~
data Proto = Proto {a :: A, b :: A, c :: C}
proto = \self -> $ Proto {
  a = fa (b self) (c self),
  b = fb (a self) (c self),
  c = fc (a self) (b self)
 }
~~~~

We can retrieve our original definitions by taking the fixpoint:

~~~~
abc = fix proto
~~~~

Of course, this works only because Haskell is lazy, and because the original
definiton did not introduce an infinite recursion in the first place.
Indeed, if the fields of the record are marked strict, this ceases to work.

And we can customize the value as follows:

~~~~
customizedA = a $ fix $ \self -> x_base {
   c = userFunction (b self)
 }
~~~~

## Conclusion

Yi is intended to be highly customizable. In many instances, we can use
compositional abstractions to provide customization. In some other instances, we
prefer to provide a prototype that user can patch. 

Despite Haskell lacking inheritance, we see that the basic concepts of lambda
expression and lazy evaluation allow to provide a very lightweight encoding for
it, and we take advantage of this in Yi.


[TAPL] http://www.cis.upenn.edu/~bcpierce/tapl/index.html