
Design plan:
        - ui type class
        - clean up ncurses code    
        - replace global var in editor state with a state monad
        - variable-size echo buffer
 
Build system:
        - check how to install it from a port script
        - think about how to do a testsuite, unit testing

v0.1:
        - line wrapping. windows need to be wrap or nowrap.
        - maybe syn hl (needs parser, in bg thread)
        - do we print '\n' at eol. what happens and eof?

other stuff:
        - bind keymap lexers to windows
        - :eval, :type, .. etc. ghci stuff
        - make the cmd line a buffer.
        - start drawing buffer before it is all loaded.
        - either generalise registers, or make them entirely keymap-local
        - other forms of undo
        - errorE should display in colour

        - try writing a user defineable Action - how to call this, other
          than by binding a key?

        - closing window and terminating on OSX produces infinite loop?

------------------------------------------------------------------------
Syntax Highlighting:

        - run a parser in background thread (of Parser class), producing a syn tree

        - abstract syn representation
            - produces syntax colouring ppr (not general ppr)
            - hints for layout (on \n, for example)

        - so we're mostly direct editing, and updating the syn tree
          where possible.

        - so how to take a syn tree and flatten it to produce a drawable buffer?
            - can we deparse it directly?   
            - or can we consult the abs syn tree, as we draw each buffer line?
                - walk the parse tree, drawing chars from the buffer in
                  the colour specified by the tree.

        - need correct position information in syn tree, to colour
          tokens. comments aren't stored in the syn tree, so how do we
          colour them?
            * Centaur records comments in the lexer, with their locations.
              Then using location information in the syntree, hook
              comments back in.

        - set of token classes?

        - need multiple entry points to the parser, to reparse subexpressions?
            - ==> Centaur (for ML) has a good system.
              ftp://ftp.inria.fr/INRIA/publication/publi-pdf/RR/part3/RR-3139.pdf

            - alredy available in Happy parser for GHC, via the %name
              directive, for:
                - parseModule module
                - parseStmt   maybe_stmt
                - parseIdentifier  identifier
                - parseIface iface
                - parseType ctype

        - can keep track of points to start reparsing from. see
          vim:syntax.c- syntax state stack cache

        - need to map tokens to attributes.

        - what about comments?
            - record the comments, with their positions, in the lexer.
            - re-splice comments back into the parse tree.


------------------------------------------------------------------------
regexes:

        - how do we handle all the different editors regex languages?
            - do they have to compile down to a core regex language,
              before calling searchE?

------------------------------------------------------------------------
GUI:
        - wolfgang has some ideas. musasabi too.
